# 0707设计链表

## 问题描述

设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

在链表类中实现这些功能：

get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

## 解法

### 节点实现

节点可以用一个类或者一个结构体来实现。成员变量有两个，一个是数据，数据类型最好用模板；一个是指针（指向下一个节点）。成员函数就是初始化的构造函数。


### 链表实现

链表的成员变量有两个，一个是链表的大小，一个是头节点。这个头节点可以是虚拟的头节点，也就是在第一个节点前再加一个头节点，目的是使得第一个节点的各种处理与普通节点无异；
一种相当于一个指标，告诉别人链表的头节点在这里

链表的基本功能通过成员函数来实现

#### 在链表头增添节点

创建一个新节点，让它的next指向原来的第一个节点，再把虚拟头节点的next指向它。顺序一定不能错，因为虚拟头节点本来是指向原来的第一个节点的，
要是先把虚拟头节点的next指向新节点了，那原来第一个头节点就找不到了，后面涉及到节点的断裂重连的操作都是这样，应该先连后面，再连前面

#### 在链表尾增添节点

链表尾的特点就是next指向的是空指针，这一点可以作为判别条件。

定义一个新节点，它的next指向空指针。

从头节点开始一直往后找，只要发现next为空的节点，就把这个节点的next只向新节点

#### 获取第index个节点的数据

链表不像数组可以通过index直接访问数据，而是要从第一个开始依次往后数。

要定义一个临时的操作指针，来充当迭代器和读取数据。

#### 在第index节点插入新节点

找到index位置在哪，和访问第index个节点差不多。

增添操作与在头节点增添节点差不多，先把新节点的next指向下一个节点，再把前一个节点的next指向新节点

#### 删除第index节点

先找index位置，再把前一个节点的next直接指向当前节点的下一个节点。

C++要注意释放掉不用的指针，即要先定义一个临时指针（浅拷贝）储存当前节点，所有操作完之后再删除掉该临时指针。