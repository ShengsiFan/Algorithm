# 0015三数之和

## 问题描述

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。


示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]

示例 2：

输入：nums = [0,1,1]
输出：[]

示例 3：

输入：nums = [0,0,0]
输出：[[0,0,0]]

## 解法

乍一看和两数之和很像，可以用哈希法。但是需要固定住前两个数，遍历第三个数。时间复杂度就是O(n^2)。

还有一种双指针法，固定住第一个数，另外两个数向中间夹逼，类似二分法。

### 双指针法

基本逻辑就是，固定住第一个数，另外两个数移动，如果和大于零，说明大了，右边的指针左移来缩小和；
如果和小于零，说明小了，中间的指针向右移来增大和。

需要注意的细节

> 去重：
> 
> 第一个数去重逻辑是，只要跟上一个数重了，就过掉它（最外层循环）。为什么不是跟下一个数比？因为下一个数可能本来就在一个满足要求的数组中了，例如{-1, -1, 2}，这样的话就漏掉了
> 
> 后面两个移动指针的去重逻辑恰好相反，如果发现下一个元素跟当前元素重了，那直接越过去。
> 
> 为什么去重不在一进while就进行？因为如果这样，那一旦发现有重的就越过去了，就不可能收割到满足条件的数组

### 哈希法

这里哈希就要用两层循环了，时间复杂度最少也是O(n)。